/**
 * @required jquery
 */
if (typeof Nico === 'undefined') {
  var Nico = {};
}

(function($) {
  Nico.LazyImage = {

    margin: document.documentElement.clientHeight || 500,
    widthMargin: document.documentElement.clientWidth || 300,
    /**
     * @type {{y: number, x: number, $image: JQuery}[][]}
     * waitings[n] には、y 座標が小さい順に、x が小さい順に並べたアイテムの配列が入っています。
     * このアイテムの x, y は enqueue されたときの座標なので、位置の変化を考慮する場合は $image.offset() で取得してください。
     *
     * このライブラリでは、y は enqueue された時点から変化しないもの、x は変化するものとして扱っています。
     * 縦スクロールは一般的だが、横スクロールするページはほとんどないので、
     * x 軸方向の見た目が変わるとすれば、dom 自体が移動したと考えられるため
     */
    waitings: [],
    className: "jsLazyImage",
    errorEventName: "jsLazyImageError",
    attrName: "data-original",
    adjustAttrName: "data-lazyimage-adjust",
    jsLazyImageTarget: 'jsLazyImageTarget',
    jsLazyImageQueued: "jsLazyImageQueued",
    y: 0,
    h: 0,
    scrollObserver: null,

    initialize: function () {
      this._getScrollPosition();
      this.waitings = [];
      var images = $("." + this.className);
      if (images.length > 0) {
        this.enqueue(images);
      }
      this._setPageObserver();
      this._setScrollObserver();
    },

    enqueue: function (images) {
      var self = this,
        maxY = this._getMaxY(),
        bottom = this._getBottomLoadingThreshold(),
        right = this._getRightLoadingThreshold();
      // waitingsを一度に突っ込むと重いのかわからないが分割してwaitingsに突っ込んでいる
      (function () {
        var proceeds = images.slice(0, 10);
        images = images.slice(10);
        var image, $image, i = 0;
        while (image = proceeds[i++]) {
          $image = $(image);
          $image.addClass(self.jsLazyImageQueued);
          var y = $image.offset().top;
          var x = $image.offset().left;
          if (y < bottom && x < right) {
            self._loadImage($image);
          } else {
            var item = { y: y, x: x, $image: $image };
            if (maxY < y) {
              self.waitings.push([item]);
              maxY = y;
            } else {
              var yIndex = self.waitings.length - 1;
              for ( ; yIndex >= 0; yIndex--) {
                if (self.waitings[yIndex][0].y < y) {
                  self.waitings.splice(yIndex + 1, 0, [item]);
                  break;
                } else if (yIndex === 0) {
                  self.waitings.splice(0, 0, [item]);
                  break;
                }

                if (self.waitings[yIndex][0].y === y) {
                  var xIndex = self.waitings[yIndex].length - 1;
                  for ( ; xIndex >= 0; xIndex--) {
                    if (self.waitings[yIndex][xIndex].x < x) {
                      self.waitings[yIndex].splice(xIndex + 1, 0, item);
                      break;
                    } else if (xIndex === 0) {
                      self.waitings[yIndex].splice(0, 0, item);
                      break;
                    }
                  }
                  break;
                }
              }
            }
          }
        }
        if (images.length > 0) {
          setTimeout(arguments.callee, 100);
        }
      })();
    },

    reset: function () {
      this.waitings = [];
      this.initialize();
    },

    /**
     * スクロールなどが起きない状況で、scrollObserver のチェックを実行したいときに呼びます
     */
    check: function () {
      this._scrollObserver();
    },

    _getMaxY: function() {
      if (this.waitings.length === 0) {
        return 0;
      }
      for (var i = this.waitings.length - 1; i >= 0; --i) {
        var headItem = this.waitings[i][0];
        if (!headItem) {
          continue;
        }
        return headItem.y;
      }
      return 0;
    },

    _getBottomLoadingThreshold: function () {
      return this.y + this.h + this.margin;
    },

    _getRightLoadingThreshold: function () {
      return this.widthMargin;
    },

    _loadImage: function ($image) {
      var src = $image.attr(this.attrName);
      if (!src) {
          return;
      }
      if ($image.is('[' + this.adjustAttrName + ']')) {
          this._adjustSizeAndLoad($image, src)
      } else {
          this._setSrc($image, src);
      }
      $image.removeClass(this.className);
      $image.removeAttr(this.attrName);
      $image.error($.proxy(function() {
        $image.trigger(this.errorEventName);
      }, this));
    },

    _setPageObserver: function () {
      if (this.pageObserver) {
        clearInterval(this.pageObserver);
      }

      var self = this;
      this.pageObserver = setInterval(function () {
        var $notQueuedImages = $("." + self.className).not("." + self.jsLazyImageQueued);
        if ($notQueuedImages.length > 0) {
          self.enqueue($notQueuedImages);
          self._scrollObserver();
        }
      }, 500);
    },

    _scrollObserver: function(){
      this._getScrollPosition();
      if (this.waitings.length == 0)
        return;
      var bottom = this._getBottomLoadingThreshold();
      var right = this._getRightLoadingThreshold();

      var yi;
      for (yi = 0; yi < this.waitings.length; yi++) {
        var headItem = this.waitings[yi][0];
        if (!headItem) {
          continue;
        }
        if (headItem.y > bottom) {
          break;
        }

        var xi;
        for (xi = 0; xi < this.waitings[yi].length; xi++) {
          var item = this.waitings[yi][xi];
          if (item.$image.offset().left < right) {
            this._loadImage(item.$image);
          } else {
            break;
          }
        }
        this.waitings[yi] = this.waitings[yi].slice(xi);
      }
      if (yi > 0) {
        this.waitings = this.waitings.filter(function(items) {
          return items.length > 0;
        });
      }
    },

    _getScrollPosition: function(){
      this.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      this.h = window.innerHeight || document.documentElement.clientHeight || document.body.offsetHeight;
    },

    _setScrollObserver: function () {
      if(this.scrollObserver){
        return;
      }
      this.scrollObserver = true;
      var self = this;
      var lastExecute = 0;
      var watcher = function(ev) {
        var now = (new Date()).getTime();
        if(now - lastExecute > 50) {
          self._scrollObserver();
          lastExecute = now;
        }
      };
      document.addEventListener('scroll', watcher);
      document.addEventListener('touchstart', watcher);
      document.addEventListener('touchmove', watcher);
    },

      /**
       * 画像のアス比を保ったまま、要素の枠に収まるように読み込む
       * @param $image
       * @param src
       * @private
       */
    _adjustSizeAndLoad: function($image, src) {
        var tmpImage = new Image();
        var self = this;
        tmpImage.onload = function () {
            var frameWidth = $image.width(), frameHeight = $image.height(),
                origWidth = tmpImage.width, origHeight = tmpImage.height,
                newWidth, newHeight;
            if (origWidth >= origHeight) {
                newWidth = frameWidth;
                newHeight = origHeight * (frameHeight / origWidth);
            } else {
                newWidth = origWidth * (frameWidth / origHeight);
                newHeight = frameHeight;
            }
            self._setSize($image, newWidth, newHeight);
            self._setSrc($image, src);
            try { tmpImage.onload = null; tmpImage = undefined; } catch (e) {}
        };
        tmpImage.src = src;
    },

    _setSrc: function($image, src) {
      if($image.prop('tagName').toLowerCase() === 'img') {
        $image.attr("src", src);
      }else{
        $image.css('background-image', 'url(' + src + ')');
      }
    },

    _setSize: function($image, newWidth, newHeight) {
      if($image.prop('tagName').toLowerCase() !== 'img') {
        return;
      }
      $image.css({
        "width":  newWidth + "px",
        "height": newHeight + "px"
      });
    }
  };

})(jQuery);
